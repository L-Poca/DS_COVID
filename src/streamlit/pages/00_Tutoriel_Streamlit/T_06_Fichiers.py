import streamlit as st
import pandas as pd
import numpy as np
from PIL import Image
import io
import base64
import json
import zipfile
from datetime import datetime
import tempfile
import os

st.header("üìÅ T_06 - Gestion Avanc√©e des Fichiers & M√©dias")

st.markdown("**üìã Objectif :** Ma√Ætriser l'upload, le traitement, la validation et le t√©l√©chargement de fichiers pour cr√©er des applications robustes et polyvalentes capables de g√©rer tous types de donn√©es et m√©dias.")

st.markdown("---")

# ================================
# 1. UPLOAD DE FICHIERS AVEC VALIDATION AVANC√âE
# ================================
st.subheader("1Ô∏è‚É£ Upload de fichiers avec validation avanc√©e")

st.markdown("""
**üìñ Description :**
L'upload de fichiers est la porte d'entr√©e des donn√©es dans votre application. Au-del√† du simple chargement,
une validation robuste garantit la s√©curit√©, la performance et la qualit√© des donn√©es trait√©es.
Streamlit offre un contr√¥le granulaire sur les types, tailles et formats accept√©s.

**üéØ Validations essentielles :**
- **Types de fichiers** : Filtrage par extensions (.csv, .xlsx, .png, etc.)
- **Taille maximum** : √âviter les fichiers trop volumineux (par d√©faut 200MB)
- **Validation du contenu** : V√©rifier la structure des donn√©es
- **S√©curit√©** : Pr√©venir l'injection de code malveillant
- **Feedback utilisateur** : Messages d'erreur clairs et informatifs

**üí° Bonnes pratiques :**
- Toujours valider c√¥t√© serveur, jamais uniquement c√¥t√© client
- D√©finir des limites de taille appropri√©es selon le use case
- Fournir des exemples de formats accept√©s
- G√©rer les erreurs avec des messages explicites
- Logger les tentatives d'upload pour audit et debug
""")

col1, col2 = st.columns(2)

with col1:
    st.markdown("#### üíª Code")
    st.code('''
# Configuration des limitations
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10 MB
ALLOWED_TYPES = ['csv', 'xlsx', 'txt', 'json']

def validate_file(uploaded_file):
    """Validation compl√®te d'un fichier upload√©"""
    if uploaded_file is None:
        return False, "Aucun fichier s√©lectionn√©"
    
    # V√©rifier la taille
    if uploaded_file.size > MAX_FILE_SIZE:
        size_mb = uploaded_file.size / (1024 * 1024)
        return False, f"Fichier trop volumineux: {size_mb:.1f}MB (max: 10MB)"
    
    # V√©rifier l'extension
    file_extension = uploaded_file.name.split('.')[-1].lower()
    if file_extension not in ALLOWED_TYPES:
        return False, f"Type non support√©: .{file_extension}"
    
    return True, "Fichier valide"

# Interface d'upload avec validation
uploaded_file = st.file_uploader(
    "S√©lectionnez votre fichier",
    type=ALLOWED_TYPES,
    help="Types accept√©s: CSV, Excel, TXT, JSON - Max 10MB"
)

if uploaded_file is not None:
    # Validation
    is_valid, message = validate_file(uploaded_file)
    
    if is_valid:
        st.success(f"‚úÖ {message}")
        
        # Informations d√©taill√©es
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("Nom", uploaded_file.name)
        with col2:
            size_mb = uploaded_file.size / (1024 * 1024)
            st.metric("Taille", f"{size_mb:.2f} MB")
        with col3:
            file_type = uploaded_file.name.split('.')[-1].upper()
            st.metric("Type", file_type)
    
    else:
        st.error(f"‚ùå {message}")
''', language="python")

with col2:
    st.markdown("#### üéØ R√©sultat")
    
    # Configuration pour la d√©mo
    demo_max_size = 5 * 1024 * 1024  # 5 MB pour la d√©mo
    demo_allowed_types = ['csv', 'xlsx', 'txt', 'json']
    
    def demo_validate_file(uploaded_file):
        if uploaded_file is None:
            return False, "Aucun fichier"
        
        if uploaded_file.size > demo_max_size:
            size_mb = uploaded_file.size / (1024 * 1024)
            return False, f"Trop volumineux: {size_mb:.1f}MB (max: 5MB)"
        
        file_extension = uploaded_file.name.split('.')[-1].lower()
        if file_extension not in demo_allowed_types:
            return False, f"Type non support√©: .{file_extension}"
        
        return True, "Fichier valide"
    
    st.markdown("**üì§ Test d'Upload**")
    demo_file = st.file_uploader(
        "Testez la validation",
        type=demo_allowed_types,
        help="CSV, Excel, TXT, JSON - Max 5MB",
        key="demo_upload_validation"
    )
    
    if demo_file is not None:
        is_valid, message = demo_validate_file(demo_file)
        
        if is_valid:
            st.success(f"‚úÖ {message}")
            
            # M√©triques
            demo_col1, demo_col2 = st.columns(2)
            with demo_col1:
                st.metric("Fichier", demo_file.name)
            with demo_col2:
                size_kb = demo_file.size / 1024
                st.metric("Taille", f"{size_kb:.1f} KB")
        
        else:
            st.error(f"‚ùå {message}")

st.divider()

# ================================
# 2. T√âL√âCHARGEMENT ET EXPORT DE DONN√âES
# ================================
st.subheader("2Ô∏è‚É£ T√©l√©chargement et export de donn√©es")

st.markdown("""
**üìñ Description :**
Le t√©l√©chargement permet aux utilisateurs d'exporter les r√©sultats de leur travail dans diff√©rents formats.
Une strat√©gie d'export bien con√ßue am√©liore l'utilisabilit√© et permet l'int√©gration avec d'autres outils.

**üéØ Formats d'export courants :**
- **CSV** : Donn√©es tabulaires, compatible Excel
- **Excel** : Feuilles multiples, formatage avanc√©
- **JSON** : Structures de donn√©es, APIs
- **PDF** : Rapports finalis√©s, pr√©sentation
- **ZIP** : Archives multiples, backup

**üí° Bonnes pratiques d'export :**
- Noms de fichiers explicites avec timestamp
- Encodage UTF-8 pour caract√®res sp√©ciaux
- M√©tadonn√©es incluses (date cr√©ation, source)
- Validation des donn√©es avant export
- Options de formatage selon l'usage
""")

col1, col2 = st.columns(2)

with col1:
    st.markdown("#### üíª Code")
    st.code('''
# Fonction utilitaire pour cr√©er des donn√©es d'exemple
def create_sample_data():
    """G√©n√®re des donn√©es d'exemple pour d√©monstration"""
    np.random.seed(42)
    data = {
        'ID': range(1, 101),
        'Nom': [f'Utilisateur_{i}' for i in range(1, 101)],
        'Age': np.random.randint(18, 65, 100),
        'Salaire': np.random.randint(30000, 80000, 100),
        'D√©partement': np.random.choice(['IT', 'RH', 'Finance', 'Marketing'], 100),
        'Performance': np.random.uniform(1, 5, 100).round(2)
    }
    return pd.DataFrame(data)

# G√©n√©ration des donn√©es d'exemple
sample_df = create_sample_data()

st.markdown("**üìä Donn√©es d'exemple √† exporter:**")
st.dataframe(sample_df.head(), use_container_width=True)

# Export CSV
st.markdown("**üìÑ Export CSV**")
csv_data = sample_df.to_csv(index=False).encode('utf-8')

st.download_button(
    label="üì• T√©l√©charger CSV",
    data=csv_data,
    file_name=f'donnees_export_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv',
    mime='text/csv',
    help="Fichier CSV compatible Excel"
)

# Export Excel avec formatage
st.markdown("**üìä Export Excel Avanc√©**")

def create_excel_download():
    """Cr√©e un fichier Excel avec formatage"""
    buffer = io.BytesIO()
    
    with pd.ExcelWriter(buffer, engine='openpyxl') as writer:
        # Feuille principale
        sample_df.to_excel(writer, sheet_name='Donn√©es', index=False)
        
        # Feuille statistiques
        stats = sample_df.describe()
        stats.to_excel(writer, sheet_name='Statistiques')
        
        # Feuille par d√©partement
        for dept in sample_df['D√©partement'].unique():
            dept_data = sample_df[sample_df['D√©partement'] == dept]
            dept_data.to_excel(writer, sheet_name=f'Dept_{dept}', index=False)
    
    return buffer.getvalue()

excel_data = create_excel_download()

st.download_button(
    label="üì• T√©l√©charger Excel (Multi-feuilles)",
    data=excel_data,
    file_name=f'rapport_complet_{datetime.now().strftime("%Y%m%d_%H%M%S")}.xlsx',
    mime='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
)

# Export JSON structur√©
st.markdown("**üîß Export JSON**")

# Cr√©er une structure JSON riche
json_export = {
    'metadata': {
        'export_date': datetime.now().isoformat(),
        'total_records': len(sample_df),
        'data_source': 'Application Streamlit Demo'
    },
    'summary': {
        'departments': sample_df['D√©partement'].unique().tolist(),
        'avg_age': float(sample_df['Age'].mean().round(1)),
        'avg_salary': float(sample_df['Salaire'].mean().round(0))
    },
    'data': sample_df.to_dict('records')
}

json_data = json.dumps(json_export, indent=2, ensure_ascii=False).encode('utf-8')

st.download_button(
    label="üì• T√©l√©charger JSON",
    data=json_data,
    file_name=f'donnees_structurees_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json',
    mime='application/json'
)
''', language="python")

with col2:
    st.markdown("#### üéØ R√©sultat")
    
    # Donn√©es d'exemple pour la d√©mo
    def create_demo_data():
        np.random.seed(42)
        data = {
            'ID': range(1, 21),
            'Produit': [f'Produit_{i}' for i in range(1, 21)],
            'Prix': np.random.randint(10, 100, 20),
            'Stock': np.random.randint(0, 50, 20),
            'Cat√©gorie': np.random.choice(['√âlectronique', 'V√™tements', 'Maison'], 20)
        }
        return pd.DataFrame(data)
    
    demo_df = create_demo_data()
    
    st.markdown("**üìä Donn√©es Demo:**")
    st.dataframe(demo_df.head(5), use_container_width=True)
    
    # Export CSV d√©mo
    demo_csv = demo_df.to_csv(index=False).encode('utf-8')
    
    st.download_button(
        label="üì• CSV Demo",
        data=demo_csv,
        file_name=f'demo_data_{datetime.now().strftime("%H%M%S")}.csv',
        mime='text/csv',
        key="demo_csv_download"
    )
    
    # Export JSON d√©mo
    demo_json_export = {
        'export_info': {
            'date': datetime.now().isoformat(),
            'records': len(demo_df)
        },
        'data': demo_df.to_dict('records')[:5]  # Limiter pour la d√©mo
    }
    
    demo_json_data = json.dumps(demo_json_export, indent=2).encode('utf-8')
    
    st.download_button(
        label="üì• JSON Demo",
        data=demo_json_data,
        file_name=f'demo_struct_{datetime.now().strftime("%H%M%S")}.json',
        mime='application/json',
        key="demo_json_download"
    )
    
    st.info("üí° Fichiers g√©n√©r√©s avec timestamp unique")

st.divider()

# ================================
# 3. GESTION D'IMAGES SIMPLIFI√âE
# ================================
st.subheader("3Ô∏è‚É£ Gestion d'images et analyse visuelle")

st.markdown("""
**üìñ Description :**
La gestion d'images permet d'enrichir les applications avec du contenu visuel.
Au-del√† de l'affichage, elle inclut l'analyse des propri√©t√©s, la validation des formats,
et des fonctionnalit√©s de traitement basique pour optimiser l'exp√©rience utilisateur.

**üéØ Fonctionnalit√©s cl√©s :**
- **Validation de formats** : PNG, JPG, JPEG, GIF
- **Analyse des propri√©t√©s** : Dimensions, taille, format
- **Redimensionnement** : Cr√©ation de miniatures
- **Affichage optimis√©** : Contr√¥le de la largeur et du cache

**üí° Bonnes pratiques :**
- Limiter la taille des fichiers pour les performances
- Cr√©er des miniatures pour les galeries
- Validation c√¥t√© serveur des formats d'image
- Gestion d'erreurs avec messages explicites
""")

col1, col2 = st.columns(2)

with col1:
    st.markdown("#### üíª Code")
    st.code('''
# Fonction d'analyse d'image
def analyze_image_simple(image_file):
    """Analyse basique d'une image"""
    try:
        image = Image.open(image_file)
        
        analysis = {
            'width': image.size[0],
            'height': image.size[1],
            'format': image.format,
            'mode': image.mode,
            'size_kb': round(image_file.size / 1024, 1)
        }
        
        return True, analysis, image
    except Exception as e:
        return False, str(e), None

# Interface d'upload d'images
st.markdown("**üñºÔ∏è Upload d'Images**")
uploaded_images = st.file_uploader(
    "S√©lectionnez des images",
    type=['png', 'jpg', 'jpeg', 'gif'],
    accept_multiple_files=True,
    help="Formats: PNG, JPG, JPEG, GIF"
)

if uploaded_images:
    st.success(f"üì∏ {len(uploaded_images)} image(s) charg√©e(s)")
    
    for idx, img_file in enumerate(uploaded_images):
        st.markdown(f"**üì∑ Image {idx + 1}: {img_file.name}**")
        
        # Analyse
        success, analysis, pil_image = analyze_image_simple(img_file)
        
        if success:
            # Affichage en colonnes
            img_col1, img_col2 = st.columns([1, 2])
            
            with img_col1:
                st.image(pil_image, caption=img_file.name, width=200)
            
            with img_col2:
                st.write(f"**Dimensions:** {analysis['width']} x {analysis['height']}")
                st.write(f"**Format:** {analysis['format']}")
                st.write(f"**Mode:** {analysis['mode']}")
                st.write(f"**Taille:** {analysis['size_kb']} KB")
                
                # Calcul des m√©gapixels
                megapixels = (analysis['width'] * analysis['height']) / 1000000
                st.write(f"**M√©gapixels:** {megapixels:.1f} MP")
        
        else:
            st.error(f"‚ùå Erreur: {analysis}")
        
        st.divider()
''', language="python")

with col2:
    st.markdown("#### üéØ R√©sultat")
    
    # D√©mo pour images
    st.markdown("**üñºÔ∏è Test Images**")
    demo_images = st.file_uploader(
        "Uploadez des images",
        type=['png', 'jpg', 'jpeg', 'gif'],
        accept_multiple_files=True,
        help="Formats accept√©s: PNG, JPG, JPEG, GIF",
        key="demo_images_upload"
    )
    
    if demo_images:
        st.success(f"üì∏ {len(demo_images)} image(s) charg√©e(s)")
        
        for idx, img_file in enumerate(demo_images[:2]):  # Limiter √† 2
            try:
                image = Image.open(img_file)
                width, height = image.size
                file_size_kb = round(img_file.size / 1024, 1)
                
                with st.expander(f"üñºÔ∏è {img_file.name}"):
                    demo_img_col1, demo_img_col2 = st.columns(2)
                    
                    with demo_img_col1:
                        st.image(image, caption=img_file.name, width=150)
                    
                    with demo_img_col2:
                        st.write(f"**Dimensions:** {width}x{height}")
                        st.write(f"**Format:** {image.format}")
                        st.write(f"**Taille:** {file_size_kb} KB")
                        
                        megapixels = round((width * height) / 1000000, 1)
                        st.write(f"**M√©gapixels:** {megapixels} MP")
            
            except Exception as e:
                st.error(f"Erreur avec {img_file.name}: {str(e)}")
        
        if len(demo_images) > 2:
            st.info(f"... et {len(demo_images) - 2} autre(s) image(s)")

st.markdown("---")

st.success("üéâ **F√©licitations !** Vous ma√Ætrisez maintenant la gestion compl√®te des fichiers et m√©dias avec Streamlit !")

st.markdown("""
**üöÄ Points cl√©s √† retenir :**

**üì§ Upload et Validation :**
- Validez toujours les fichiers c√¥t√© serveur
- D√©finissez des limites de taille appropri√©es
- Fournissez des messages d'erreur clairs
- Supportez les formats m√©tier essentiels

**üì• Export et T√©l√©chargement :**
- Proposez plusieurs formats selon l'usage
- Ajoutez des timestamps aux noms de fichiers
- Incluez des m√©tadonn√©es dans les exports
- Optimisez pour l'int√©gration avec d'autres outils

**üñºÔ∏è Gestion d'Images :**
- Analysez les propri√©t√©s pour validation
- Cr√©ez des miniatures pour les performances
- G√©rez les erreurs de format gracieusement
- Optimisez l'affichage selon le contexte

**üîó Prochaine √©tape :** Explorez T_08_Performance pour optimiser vos applications Streamlit !
""")
